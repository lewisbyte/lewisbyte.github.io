<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>保持好奇心</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="保持好奇心">
<meta property="og:url" content="https://lewisbyte.github.io/index.html">
<meta property="og:site_name" content="保持好奇心">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lewis">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="保持好奇心" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">保持好奇心</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">lewis的随笔记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lewisbyte.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-db" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/07/db/" class="article-date">
  <time class="dt-published" datetime="2024-04-07T02:41:06.077Z" itemprop="datePublished">2024-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/07/db/">数据库相关</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>记录数据库相关的疑难杂症</li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="neo4j">neo4j</a></li>
</ul>
<h3 id="neo4j"><a href="#neo4j" class="headerlink" title="neo4j"></a>neo4j</h3><ul>
<li><p>1.通讯协议：</p>
<ul>
<li>Q:  为什么图库使用 neo4j 的 bolt 链接协议，出现了无法找到主节点导致无法写入或者读取的问题？</li>
<li>A：neo4j支持3种通讯协议：<ul>
<li><p>bolt+routing（适用于集群，目前图平台不支持此协议）</p>
</li>
<li><p>bolt（适用于单机）</p>
</li>
<li><p>neo4j（适用于集群）</p>
</li>
<li><p>bolt 适用于单节点的图数据库。集群模式下的图库需要支持路由的neo4j协议进行通信，从而将请求转发到对应的数据节点上。</p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://neo4j.com/docs/driver-manual/1.7/client-applications/#driver-connection-uris">https://neo4j.com/docs/driver-manual/1.7/client-applications/#driver-connection-uris</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.数据接入</p>
<ul>
<li>Q:  为什么出现hive数据无法接入图库？datax是否支持mysql 导入neo4j ? 什么类型的数据接入可以导入到neo4j？</li>
<li>A: 不支持；不支持；目前图平台只支持文件模式导入数据到图平台</li>
</ul>
</li>
<li><p>3.数据库命名规范：</p>
<ul>
<li>Q:  为什么出现了图数据库创建失败的问题？</li>
<li>A：neo4j 有自己的数据库规范，这里需要按照neo4j的规范进行创建，所以对应的图实例也要按照规范进行校验</li>
</ul>
</li>
<li><p>4.边关系查询缓慢：</p>
<ul>
<li><p>Q: 为什么图析界面，点击查询边关系出现超时？</p>
</li>
<li><p>A： neo4j 4.1.x版本的图库，不支持关系边表索引建立。如图所示通过主键查询的检索模式是 AllNodesScan 全表扫描（性能调优参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37503890/article/details/102073193%EF%BC%89%EF%BC%8C2%E4%BA%BF%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E9%97%B4%E8%80%97%E6%97%B6%E7%BA%A6%E4%B8%BA10s%E5%B7%A6%E5%8F%B3%E3%80%82">https://blog.csdn.net/qq_37503890/article/details/102073193），2亿的数据量查询的时间耗时约为10s左右。</a></p>
<ul>
<li>解决方案：将关系边数据导入到es，通过es查询，不通过图库查询。</li>
</ul>
</li>
</ul>
</li>
<li><p>5.neo4j 的数据库链接泄露，句柄数量增长非常快</p>
<ul>
<li>A：数据库链接没有及时释放导致的数据库链接泄露，及时释放neo4j的连接即可<ul>
<li>微服务句柄数量超过限制问题汇总</li>
</ul>
</li>
</ul>
</li>
<li><p>7.neo4j 在使用ETL导入时，出现死锁现象：</p>
<ul>
<li><p>Q: 在使招行AI实验室项目中，图平台[3.1.2.69] 用spark 集群对neo4j批量导入关系边数据的时候，总是会出现报错：ForsetiClient can’t acquire ExclusiveLock（参考：<a target="_blank" rel="noopener" href="https://github.com/neo4j/neo4j/issues/6248%EF%BC%89">https://github.com/neo4j/neo4j/issues/6248）</a></p>
</li>
<li><p>A:</p>
<ul>
<li><p>在使用集群导数，一般是多个作业实例执行导入任务，这里就会出现并发写入的场景。neo4j的边关系写入的操作时，数据库本身会给每一个写入操作的事务分配一把排它锁（exclusiveLock），多并发写入就会出现事务之间锁的争夺情况。在实际的生产环境中观察到，最多有130个事务卡在获取锁，最后导致事务超时，整体数据导入任务失败。</p>
</li>
<li><p>解决方法是：需要降低单次事务写入数据库的数据量。单次写入大量数据非常耗时，从而降低每次事务的耗时，及时将锁资源释放出来，避免发生事务超时的死锁</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>提高单次事务的超时时间。避免出现多个不同事务之间的锁资源竞争时，没有足够的等待时间，导致的任务失败。<br>调整taurus-app配置，降低etl任务的spark executor的数量。从源头降低并发，减少锁资源竞争<br>调整spark配置：[ spark.dynamicAllocation.enabled    false ] ，关闭 动态资源分配功能<br>调整 etl的spark 任务参数，限制最大：1个instances，1个cores，避免多进程并发写入导致的死锁问题</p>
<ul>
<li><p>8.出现报错：Could not perform discovery. No routing servers available</p>
<ul>
<li>A：neo4j 的服务宕机，需要管理员维护</li>
</ul>
</li>
<li><p>9.使用图平台文件导入大数据量到neo4j宕机</p>
<ul>
<li><p>A: graph系统在使用文件导入120w条数据，具体表现为会出现jvm内存耗尽，机器不再接受写入请求</p>
</li>
<li><p>Q: DBA解释为cypher语句太长，堆积在内存中无法释放导致的内存耗尽，需要优化语句，建议使用unwind优化cypher语句</p>
</li>
<li><p>neo4j批量入数优化分析及实现</p>
</li>
</ul>
</li>
<li><ol start="10">
<li>数据导入neo4j 出现 heap 堆内存溢出，表现为老年代（old gen）持续增长，不会下降</li>
</ol>
</li>
</ul>
<p>现象如下图:</p>
<ul>
<li>A:<ul>
<li><p>neo4j批量入数优化分析及实现</p>
<ul>
<li><p>使用csv文件导数到es和图库。由于csv文件非常巨大，发现2个主要问题：</p>
</li>
<li><p>导数速率很慢，单次只能写入100条数据，如果数据量在50w的实体表，一般就需要耗时1-2小时才能完成导数任务。</p>
</li>
<li><p>在实现导数的方式上有问题，批量导数实现上本质是拼接一个巨长的cypher语句，在小数据量的情况下不会有什么问题。但是如果在大数据量下，会提交很多的长语句，从而会出现neo4j图库无法及时处理这些超长的cypher语句，堆积在JVM的老年代内存中无法释放，最后neo4j出现内存OOM宕机。</p>
</li>
</ul>
</li>
<li><p>优化分析：</p>
<ul>
<li>在搞清原因之后，咨询DBA了解到，neo4j不建议使用长语句，最好是使用短语句来插入数据，长语句会产生堆积，进而导致内存不足。但是短语句的矛盾就在于性能低下，我们这里需要使用批量插入的模式提高性能。</li>
<li>于是在参考了neo4j-spark的源码实现，得到了启发。neo4j官方sprak的导数实现是使用批量插入的模式，不是通过拼接语句的模式。通过使用参数传递模式进行批量插入，以实体插入为例：</li>
<li>scala源码实现（org.neo4j.spark.service.Neo4jQueryWriteStrategy#createStatementForNodes）：</li>
<li>编译后的语句：</li>
<li>with query: UNWIND $events AS event MERGE (node:Human {object_key: event.keys.object_key}) SET node +&#x3D; event.properties</li>
<li>这里官方实现使用了unwind关键字，这里引用 博文 解释为什么unwind可以加速插入：</li>
<li>高效的做法是利用Neo4j提供的参数（Parameter）机制和UNWIND子句：在一次数据更新中，进行一次连接，打开一次事务，批量更新数据；参数用于提供列表格式的数据，UNWIND子句是把列表数据展开成一行一行的数据，每行数据都会执行结构相同的Cypher语句。再批量更新图形数据之前，用户必须构造结构固定的、参数化的Cypher语句。当Cypher语句的结构相同时，Neo4j数据库直接从缓存中复用已生成的执行计划，而不需要重新生成，这也能够提高查询性能。</li>
<li>UNWIND子句把列表式的数据展开成一行一行的数据，每一个行都包含更新所需要的全部信息，列表式的数据，可以通过参数来传递。</li>
<li>例如，定义参数events，该参数是一个JSON字符串，键events是参数名，其值是一个数组，包含两个数组元素。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;events&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span>  <span class="attr">&quot;year&quot;</span> <span class="punctuation">:</span> <span class="number">2014</span><span class="punctuation">,</span> <span class="attr">&quot;id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span><span class="attr">&quot;year&quot;</span> <span class="punctuation">:</span> <span class="number">2014</span><span class="punctuation">,</span> <span class="attr">&quot;id&quot;</span> <span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过$events引用参数，UNWIND子句把events数组中的两个元素展开，每个元素执行一次Cypher语句，由于Cypher的语句结构固定，因此，执行计划被缓存起来，在执行数据更新任务时，参数被UNWIND子句展开，复用执行计划，提高数据更新的速度。</li>
<li>实施方法：实体数据批量插入cypher，采用overwrite模式进行数据创建和合并，依据object_key作为唯一键进行对象合并：</li>
<li>关系边数据批量插入cypher，采用overwrite模式进行数据的创建和合并，依据object_key作为唯一键进行对象合并：</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lewisbyte.github.io/2024/04/07/db/" data-id="clwr6bi4j0002e7wy2kyj16rs" data-title="数据库相关" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-distribute_alg" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/20/distribute_alg/" class="article-date">
  <time class="dt-published" datetime="2024-02-20T08:03:25.871Z" itemprop="datePublished">2024-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/20/distribute_alg/">分布式技术原理与算法解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>分布式技术原理与算法解析</li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><p><a href="%E9%80%89%E4%B8%BE">选举</a></p>
</li>
<li><p>Bully 算法是一种霸道的集群选主算法，为什么说是霸道呢？因为它的选举原则是“长者”为大，即在所有活着的节点中，选取 ID 最大的节点作为主节点。它的假设条件是，集群中每个节点均知道其他节点的 ID</p>
</li>
<li><p>Raft 算法是典型的多数派投票选举算法，其选举机制与我们日常生活中的民主投票机制类似，核心思想是“少数服从多数”。也就是说，Raft 算法中，获得投票最多的节点成为主。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lewisbyte.github.io/2024/02/20/distribute_alg/" data-id="clwr6bi4k0003e7wyh6ce2x7i" data-title="分布式技术原理与算法解析" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-compiler" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/31/compiler/" class="article-date">
  <time class="dt-published" datetime="2024-01-31T08:17:29.263Z" itemprop="datePublished">2024-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/31/compiler/">编译原理相关</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>编译原理相关</li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#antlr4%E7%9A%84%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85">antlr4的本地配置安装</a></li>
<li><a href="#%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">巴科斯范式</a></li>
</ul>
<h3 id="antlr4的本地配置安装"><a href="#antlr4的本地配置安装" class="headerlink" title="antlr4的本地配置安装"></a>antlr4的本地配置安装</h3><ul>
<li><ol>
<li>下载antlr到本地机器: <code>wget http://www.antlr.org/download/antlr-4.11.1-complete.jar</code>，将本地JDK版本调整至 JDK-11 或以上版本即可。</li>
</ol>
</li>
<li><ol start="2">
<li>在本地 <code>~/.bash_profile</code> 添加以下环境变量</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#antlr4</span></span><br><span class="line"><span class="built_in">export</span> ANTLR_PATH=/Users/lewis/soft_repo/antlr/antlr-4.11.1-complete.jar</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$ANTLR_PATH</span></span><br><span class="line"><span class="built_in">alias</span> antlr4=<span class="string">&#x27;java org.antlr.v4.Tool&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grun=<span class="string">&#x27;java org.antlr.v4.gui.TestRig&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>执行<code>source ~/.bash_profile</code>，刷新当前终端环境变量，输入：<code>antlr4</code> 验证是否成功，如果成功则出现以下信息输出：</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ antlr4</span><br><span class="line">ANTLR Parser Generator  Version 4.11.1</span><br><span class="line"> -o ___              specify output directory <span class="built_in">where</span> all output is generated</span><br><span class="line"> -lib ___            specify location of grammars, tokens files</span><br><span class="line"> -atn                generate rule augmented transition network diagrams</span><br><span class="line"> -encoding ___       specify grammar file encoding; e.g., euc-jp</span><br><span class="line"> -message-format ___ specify output style <span class="keyword">for</span> messages <span class="keyword">in</span> antlr, gnu, vs2005</span><br><span class="line"> -long-messages      show exception details when available <span class="keyword">for</span> errors and warnings</span><br><span class="line"> -listener           generate parse tree listener (default)</span><br><span class="line"> -no-listener        don<span class="string">&#x27;t generate parse tree listener</span></span><br><span class="line"><span class="string"> -visitor            generate parse tree visitor</span></span><br><span class="line"><span class="string"> -no-visitor         don&#x27;</span>t generate parse tree visitor (default)</span><br><span class="line"> -package ___        specify a package/namespace <span class="keyword">for</span> the generated code</span><br><span class="line"> -depend             generate file dependencies</span><br><span class="line"> -D&lt;option&gt;=value    <span class="built_in">set</span>/override a grammar-level option</span><br><span class="line"> -Werror             treat warnings as errors</span><br><span class="line"> -XdbgST             launch StringTemplate visualizer on generated code</span><br><span class="line"> -XdbgSTWait         <span class="built_in">wait</span> <span class="keyword">for</span> STViz to close before continuing</span><br><span class="line"> -Xforce-atn         use the ATN simulator <span class="keyword">for</span> all predictions</span><br><span class="line"> -Xlog               dump lots of logging info to antlr-timestamp.log</span><br><span class="line"> -Xexact-output-dir  all output goes into -o <span class="built_in">dir</span> regardless of paths/package</span><br></pre></td></tr></table></figure>

<h3 id="巴科斯范式"><a href="#巴科斯范式" class="headerlink" title="巴科斯范式"></a>巴科斯范式</h3><p>“巴科斯范式”，简称 BNF。Antlr 和 Yacc 这两个工具都用这种写法。为了简化书写，我有时会在课程中把“::&#x3D;”简化成一个冒号。你看到的时候，知道是什么意思就可以了。</p>
<p>你有时还会听到一个术语，叫做扩展巴科斯范式 (EBNF)。它跟普通的 BNF 表达式最大的区别，就是里面会用到类似正则表达式的一些写法。比如下面这个规则中运用了 * 号，来表示这个部分可以重复 0 到多次：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lewisbyte.github.io/2024/01/31/compiler/" data-id="clwr6bi4h0001e7wybxz9fvv9" data-title="编译原理相关" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-k8s" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/21/k8s/" class="article-date">
  <time class="dt-published" datetime="2023-11-21T01:53:03.366Z" itemprop="datePublished">2023-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/21/k8s/">K8S 自学总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="模板类型"><a href="#模板类型" class="headerlink" title="模板类型"></a>模板类型</h3><ul>
<li>deployment：无状态服务（在线）</li>
<li>stateful：有状态服务（在线）</li>
<li>batch：离线计算服务<ul>
<li>CronJob：定时离线任务</li>
<li>Job：普通离线任务</li>
</ul>
</li>
<li>Ingress：代理不同后端 Service 而设置的负载均衡服务</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lewisbyte.github.io/2023/11/21/k8s/" data-id="clwr6bi4o0005e7wy3d2537oe" data-title="K8S 自学总结" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-cafebabe" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/01/cafebabe/" class="article-date">
  <time class="dt-published" datetime="2023-09-01T02:20:47.883Z" itemprop="datePublished">2023-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/01/cafebabe/">Java疑难杂症-LTS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>记录java开发中遇到的疑难杂症，长期更新维护</li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="1">1</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lewisbyte.github.io/2023/09/01/cafebabe/" data-id="clwr6bi470000e7wye9p7fks9" data-title="Java疑难杂症-LTS" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-elasticsearch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/08/elasticsearch/" class="article-date">
  <time class="dt-published" datetime="2023-08-08T06:28:03.797Z" itemprop="datePublished">2023-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/08/elasticsearch/">ElasticSearch源码学习-LTS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>用于个人学习总结ElasticSearch</li>
<li>包括基础使用、运行机制、源码解析等</li>
<li>源码基于 6.1 分支: <a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch/tree/6.1">ElasticSearch-6.1分支代码</a></li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95">如何调试</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D">源码目录介绍</a></li>
<li><a href="#ES%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E6%AD%A5%E9%AA%A4">ES集群启动步骤</a></li>
<li><a href="#ES%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E6%AD%A5%E9%AA%A4">ES集群启动步骤</a></li>
<li><a href="#ES%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">ES数据模型</a></li>
<li><a href="#ES%E4%B8%BB%E5%88%86%E7%89%87%E9%80%89%E4%B8%BE%E7%AD%96%E7%95%A5">ES主分片选举策略</a></li>
<li><a href="#ES%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B">ES写入流程</a></li>
<li><a href="#"></a></li>
</ul>
<h3 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h3><ul>
<li><ol>
<li>编译构建elasticsearch工程: <code>./gradlew assemble</code></li>
</ol>
</li>
<li><ol start="2">
<li>将工程集成到IDEA: <code>./gradlew idea</code>，用IDEA打开elasticsearch工程</li>
</ol>
</li>
<li><ol start="3">
<li>执行 <code>./gradlew :run --debug-jvm</code>，启动调试模式.</li>
</ol>
</li>
<li><ol start="4">
<li>debug启动之后，观察日志：<code>[elasticsearch] Listening for transport dt_socket at address: 8000</code>发现debug端口为<code>8000</code>.</li>
</ol>
</li>
<li><ol start="5">
<li>添加远程JVM调试，主机填<code>localhost</code>,端口配置为<code>8000</code>,JDK选择 <code>5-8</code>，点击确定启动debug</li>
</ol>
</li>
<li><img src="/image/003-debug.png" alt="debug 配置"></li>
<li><ol start="6">
<li>可以观察日志，服务已经正常启动</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[elasticsearch] [2023-07-26T16:19:14,233][INFO ][o.e.t.TransportService   ] [node-0] publish_address &#123;127.0.0.1:9300&#125;, bound_addresses &#123;[::1]:9300&#125;, &#123;127.0.0.1:9300&#125;</span><br><span class="line">[elasticsearch] [2023-07-26T16:19:17,300][INFO ][o.e.c.s.MasterService    ] [node-0] zen-disco-elected-as-master ([0] nodes joined), reason: new_master &#123;node-0&#125;&#123;48qziOzRTdOSQo0nQhQ_PQ&#125;&#123;udw-kDLxTNCvBvup2R2Nqw&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;&#123;testattr=test&#125;</span><br><span class="line">[elasticsearch] [2023-07-26T16:19:17,304][INFO ][o.e.c.s.ClusterApplierService] [node-0] new_master &#123;node-0&#125;&#123;48qziOzRTdOSQo0nQhQ_PQ&#125;&#123;udw-kDLxTNCvBvup2R2Nqw&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;&#123;testattr=test&#125;, reason: apply cluster state (from master [master &#123;node-0&#125;&#123;48qziOzRTdOSQo0nQhQ_PQ&#125;&#123;udw-kDLxTNCvBvup2R2Nqw&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;&#123;testattr=test&#125; committed version [1] source [zen-disco-elected-as-master ([0] nodes joined)]])</span><br><span class="line">[elasticsearch] [2023-07-26T16:19:17,329][INFO ][o.e.g.GatewayService     ] [node-0] recovered [0] indices into cluster_state</span><br><span class="line">[elasticsearch] [2023-07-26T16:19:17,331][INFO ][o.e.h.n.Netty4HttpServerTransport] [node-0] publish_address &#123;127.0.0.1:9200&#125;, bound_addresses &#123;[::1]:9200&#125;, &#123;127.0.0.1:9200&#125;</span><br><span class="line">[elasticsearch] [2023-07-26T16:19:17,333][INFO ][o.e.n.Node               ] [node-0] started</span><br><span class="line">&lt;============-&gt; 96% EXECUTING [11m 35s]</span><br><span class="line">&gt; :distribution:run#start</span><br><span class="line">&gt; IDLE</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="7">
<li>在浏览器访问: <code>http://127.0.0.1:9200/</code></li>
</ol>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;node-0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;distribution_run&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;otLdQ8YGRDuaRDHHW2ly9w&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6.1.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;c975590&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2023-07-13T06:34:36.143Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;7.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;5.6.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;5.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="源码目录介绍"><a href="#源码目录介绍" class="headerlink" title="源码目录介绍"></a>源码目录介绍</h3><ul>
<li><p>1.buildSrc</p>
<ul>
<li>包含 Gradle 构建脚本的定制逻辑。Elasticsearch 使用 Gradle 进行构建和管理依赖，这个目录存放了构建过程中所需的自定义插件和配置。</li>
</ul>
</li>
<li><p>2.client</p>
<ul>
<li>包含与 Elasticsearch 交互的客户端代码。</li>
<li>client&#x2F;java-rest: Java REST 客户端，提供与 Elasticsearch REST API 的交互。</li>
<li>client&#x2F;transport: 旧的 Java Transport 客户端（已被废弃），通过自定义的二进制协议与集群通信。</li>
</ul>
</li>
<li><p>3.distribution</p>
<ul>
<li>包含用于打包 Elasticsearch 发行版的代码。</li>
<li>distribution&#x2F;docker: 用于构建 Elasticsearch Docker 镜像的相关文件。</li>
<li>distribution&#x2F;archives: 用于创建 zip 和 tar.gz 发行包的配置。</li>
</ul>
</li>
<li><p>4.libs</p>
<ul>
<li>包含独立于 Elasticsearch 其他部分的通用库和实用工具。</li>
<li>libs&#x2F;core: 核心库，包含了一些通用的工具类和基础设施代码。</li>
<li>libs&#x2F;geo: 处理地理空间数据的库。</li>
</ul>
</li>
<li><p>5.modules</p>
<ul>
<li>包含 Elasticsearch 的核心模块，这些模块是内置的功能插件。</li>
<li>modules&#x2F;analysis-common: 常见的文本分析器模块。</li>
<li>modules&#x2F;lang-painless: Painless 脚本语言模块。</li>
<li>modules&#x2F;reindex: 支持重新索引操作的模块。</li>
</ul>
</li>
<li><p>6.plugins</p>
<ul>
<li>包含官方提供的 Elasticsearch 插件。</li>
<li>plugins&#x2F;analysis-phonetic: 语音分析插件。</li>
<li>plugins&#x2F;mapper-annotated-text: 注释文本映射插件。</li>
<li>plugins&#x2F;repository-s3: S3 存储库插件，用于将快照存储在 AWS S3 上。</li>
</ul>
</li>
<li><p>7.server</p>
<ul>
<li>核心服务器代码，包含了 Elasticsearch 的大部分功能逻辑。</li>
<li>server&#x2F;src&#x2F;main: 主源码目录，包含核心功能实现。</li>
<li>java&#x2F;org&#x2F;elasticsearch&#x2F;action: 包含所有的操作（actions），如索引、搜索等操作的实现。</li>
<li>java&#x2F;org&#x2F;elasticsearch&#x2F;cluster: 集群管理相关的代码。</li>
<li>java&#x2F;org&#x2F;elasticsearch&#x2F;index: 索引管理和操作相关的代码。</li>
<li>java&#x2F;org&#x2F;elasticsearch&#x2F;node: 节点相关的代码，定义了 Elasticsearch 节点的行为。</li>
</ul>
</li>
<li><p>8.test</p>
<ul>
<li>包含测试代码和测试框架。</li>
<li>test&#x2F;framework: 测试框架代码，提供了一些基础的测试工具和配置。</li>
<li>test&#x2F;fixtures: 一些测试夹具，用于集成测试。</li>
</ul>
</li>
<li><p>9.x-pack</p>
<ul>
<li>包含 X-Pack 组件，提供了额外的功能，如安全、监控、机器学习等。</li>
<li>x-pack&#x2F;plugin: X-Pack 插件的具体实现。</li>
<li>x-pack&#x2F;qa: X-Pack 的质量保证（QA）测试代码。</li>
<li>x-pack&#x2F;spec: 规范和文档。</li>
</ul>
</li>
</ul>
<h3 id="ES集群启动步骤"><a href="#ES集群启动步骤" class="headerlink" title="ES集群启动步骤"></a>ES集群启动步骤</h3><ul>
<li><ol>
<li>选举主节点（过半数为master节点）</li>
</ol>
</li>
<li><ol start="2">
<li>选举集群元信息</li>
</ol>
</li>
<li><ol start="3">
<li>allocation分配数据分片</li>
</ol>
</li>
<li><ol start="4">
<li>index recovery 索引重启恢复</li>
</ol>
</li>
<li><ol start="5">
<li>集群启动</li>
</ol>
</li>
</ul>
<h3 id="ES数据模型"><a href="#ES数据模型" class="headerlink" title="ES数据模型"></a>ES数据模型</h3><ul>
<li>1 数据副本模型基于主从模式（或称主备模式，HDFS和 Cassandra为对等模式），在实现过程中参考了微软的PacificA算法</li>
<li>2 数据副本模型：<ul>
<li>ES的数据副本模型基于主备模式</li>
<li>每个索引都会被拆分为多个分片，并且每个分片都有多个副本(这些副本称为replication group)</li>
</ul>
</li>
<li>3 写入过程：<ul>
<li>请求到达协调节点：（request-&gt;coordinator）</li>
<li>协调节点先验证操作：（coordinator-&gt;validation）</li>
<li>协调节点转发到主分片（coordinator—&gt;routing to-&gt; master node)</li>
<li>主节点本地更新操作（ master node update）</li>
<li>主节点下发数据同步给副本节点组（master node-&gt;slave nodes）</li>
<li>一旦所有的副分片成功执行操作并回复主分片，主分片会把 请求执行成功的信息返回给协调节点，协调节点返回给客户端</li>
</ul>
</li>
<li>4 故障处理<ul>
<li>出现主分片错误：如离线、磁盘损坏等，会超时（1分钟）之后主动降级，提升一个副分片为主分片</li>
<li>出错的主分片操作会被副分片拒绝：来自陈旧的主分片的操作将会被副分片拒绝。当它接收来自副分片的拒绝其请求的响应时，它将会访问一下（新）主节点，然后就会知道自己已被替换。最后将操作路由到新的主分片。</li>
</ul>
</li>
<li>5 读取模型<ul>
<li>把读请求转发到相关分片</li>
<li>从副本组中选择一个相关分片的活跃副本</li>
<li>发送分片级的读请求到被选中的副本</li>
<li>合并结果并给客户端返回响应</li>
</ul>
</li>
</ul>
<h3 id="ES主分片选举策略"><a href="#ES主分片选举策略" class="headerlink" title="ES主分片选举策略"></a>ES主分片选举策略</h3><ul>
<li>安全地分配主分片<ul>
<li>分片决策过程在主节点完成，并记录在集群状态中</li>
<li>为了确保安全，主节点必须确保被选为主分片的副本含有最新数据。为 此，ES 使用 Allocation IDs 的概念，这是区分不同分片的唯一标识</li>
</ul>
</li>
<li>分片时序id(Sequence IDs)<ul>
<li>本地及全局检查点（global checkpoint） ：全局检查点是所有活跃分片历史都已对齐的序列号，换句话说，所 有低于全局检查点的操作都保证已被所有活跃的分片处理完毕。这意味 着，当主分片失效时，我们只需要比较新主分片与其他副分片之间的最 后一个全局检查点之后的操作即可。当旧主分片恢复时，我们使用它知 道的全局检查点，与新主分片进行比较。这样，我们只有小部分操作需 要比较，不用比较全部</li>
</ul>
</li>
<li>_version<ul>
<li>1.是实现乐观锁，如同其他数据库的乐观锁一 样。我们在写请求中指定文档的版本号，如果文档的当前版本与请求中 指定的版本号不同，则请求会失败。</li>
<li>2.当文档被修改时版本号递 增。ES 使用这个_version来确保变更以正确顺序执行</li>
</ul>
</li>
</ul>
<h3 id="ES写入流程"><a href="#ES写入流程" class="headerlink" title="ES写入流程"></a>ES写入流程</h3><ul>
<li><p>基本流程：</p>
<ul>
<li><ol>
<li>客户端发出请求到es服务端协调节点</li>
</ol>
</li>
<li><ol start="2">
<li>协调节点确定数据所属分片主节点，将请求路由转发到主分片节点</li>
</ol>
</li>
<li><ol start="3">
<li>主分片节点执行写操作，并将请求写入到副本节点，等待所有副本节点写入成功</li>
</ol>
</li>
<li><ol start="4">
<li>主分片节点向协调节点报告，协调节点向客户端报告成功</li>
</ol>
</li>
<li>写一致性的默认策略是quorum，即多数的分片（其中分片副本可以 是主分片或副分片）在写入操作时处于可用状态。</li>
<li>quorum &#x3D; int（（primary + number_of_replicas） &#x2F; 2 ） + 1</li>
</ul>
</li>
<li><p>详细流程</p>
</li>
</ul>
<h3 id="ES-GET流程"><a href="#ES-GET流程" class="headerlink" title="ES-GET流程"></a>ES-GET流程</h3><ul>
<li>基本流程：<ul>
<li><ol>
<li>客户端请求node节点（coordinator 协调节点）</li>
</ol>
</li>
<li><ol start="2">
<li>node节点使用文档id确定数据分片，将请求转发给任意一个分片副本节点</li>
</ol>
</li>
<li><ol start="3">
<li>副本节点返回对应文档数据，node返回数据给客户端</li>
</ol>
</li>
</ul>
</li>
<li>详细流程<br><img src="/image/010.png" alt="GET详细流程"></li>
</ul>
<h3 id="Search流程"><a href="#Search流程" class="headerlink" title="Search流程"></a>Search流程</h3><ul>
<li><p>索引和搜索<br><img src="/image/011.png" alt="索引流程"></p>
</li>
<li><p>分布式搜索过程</p>
<ul>
<li>实现类：<code>org.elasticsearch.rest.action.search.RestSearchAction</code></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lewisbyte.github.io/2023/08/08/elasticsearch/" data-id="clwr6bi4n0004e7wyeomb7h8b" data-title="ElasticSearch源码学习-LTS" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/03/linux/" class="article-date">
  <time class="dt-published" datetime="2023-07-03T06:49:33.737Z" itemprop="datePublished">2023-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/03/linux/">Linux应用性能调优-LTS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>总结、收集 Linux 实用命令、系统应用调优相关的技巧</li>
<li>本文基于 Ubuntu-22.04、Centos-7 版本</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li><a href="#%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">内存问题分析</a></li>
<li><a href="#CPU%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">CPU问题分析</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">磁盘问题分析</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">网络问题分析</a></li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">系统信息</a><ul>
<li><a href="#top">系统信息-top</a></li>
<li><a href="#sar">系统信息-sar</a></li>
<li><a href="#watch">系统信息-watch</a></li>
<li><a href="#pidstat">系统信息-pidstat</a></li>
<li><a href="#mpstat">系统信息-mpstat</a></li>
<li><a href="#vmstat">系统信息-vmstat</a></li>
<li><a href="#dstat">系统信息-dstat</a></li>
<li><a href="#cachestat">系统信息-cachestat</a></li>
<li><a href="#cachetop">系统信息-cachetop</a></li>
<li><a href="#slabtop">系统信息-slabtop</a></li>
<li><a href="#strace">系统信息-strace</a></li>
<li><a href="#perf">系统信息-perf</a></li>
<li><a href="#pstree">系统信息-pstree</a></li>
<li><a href="#valgrind">系统信息-valgrind</a></li>
<li><a href="#procfs">系统信息-procfs</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%A3%81%E7%9B%98">文件磁盘</a><ul>
<li><a href="#iostat">磁盘信息-iostat</a></li>
<li><a href="#iotop">磁盘信息-iotop</a></li>
<li><a href="#lsof">文件信息-lsof</a><br>-<a href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95">系统测试</a></li>
<li><a href="#stress">测试-cpu-stress</a></li>
<li><a href="#sysbench">测试-系统-sysbench</a></li>
<li><a href="#dd">测试-磁盘-dd</a></li>
<li><a href="#fio">测试-磁盘-fio</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C">网络</a><ul>
<li><a href="#nslookup">网络调试-nslookup</a></li>
<li><a href="#dig">网络调试-dig</a></li>
<li><a href="#ping">网络测试-ping</a></li>
<li><a href="#iperf">网络测试-iperf</a></li>
<li><a href="#tcpdump">网络信息-tcpdump</a></li>
</ul>
</li>
</ul>
<h3 id="CPU问题分析"><a href="#CPU问题分析" class="headerlink" title="CPU问题分析"></a>CPU问题分析</h3><p><img src="/image/002-cpu.png" alt="CPU问题分析图"></p>
<h3 id="内存问题分析"><a href="#内存问题分析" class="headerlink" title="内存问题分析"></a>内存问题分析</h3><p><img src="/image/001-mem.png" alt="内存问题分析图"></p>
<h3 id="磁盘问题分析"><a href="#磁盘问题分析" class="headerlink" title="磁盘问题分析"></a>磁盘问题分析</h3><p><img src="/image/005-disk.png" alt="磁盘问题分析图"></p>
<h3 id="网络问题分析"><a href="#网络问题分析" class="headerlink" title="网络问题分析"></a>网络问题分析</h3><p><img src="/image/009.png" alt="磁盘问题分析图"></p>
<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><ul>
<li><p>[简介]: top （table of processes）是一个任务管理器程序，它可运行于许多类Unix操作系统上，它用于显示有关CPU和内存利用率的信息。</p>
</li>
<li><p>us: 用户态使用率</p>
</li>
<li><p>sy: 内核态使用率</p>
</li>
<li><p>id: 空闲率</p>
</li>
<li><p>Mem: 物理内存使用量</p>
</li>
<li><p>Swap: 虚拟内存分区使用量</p>
</li>
<li><p>进程关键指标: S 列（也就是 Status 列）含义</p>
<ul>
<li>R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</li>
<li>D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</li>
<li>Z 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是 进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。</li>
<li>I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高，I 状态的进程却不会。</li>
</ul>
</li>
<li><p>VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。</p>
</li>
<li><p>RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。</p>
</li>
<li><p>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。</p>
</li>
<li><p>%MEM 是进程使用物理内存占系统总内存的百分比。</p>
</li>
</ul>
<h3 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h3><ul>
<li><p>[简介]:sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据和分析的结果都可以存入文件，所需的负载很小。sar是目前Linux上最为全面的系统性能分析工具之一，可以从14个大方面对系统的活动进行报告，包括文件的读写情况、系统调用的使用情况、串口、CPU效率、内存使用状况、进程活动及IPC有关的活动等，使用也是较为复杂。</p>
</li>
<li><p>sar -u : 默认情况下显示的cpu使用率等信息就是sar -u；</p>
<ul>
<li>%user 用户模式下消耗的CPU时间的比例；</li>
<li>%nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</li>
<li>%system 系统模式下消耗的CPU时间的比例；</li>
<li>%iowait CPU等待磁盘I&#x2F;O导致空闲状态消耗的时间比例；</li>
<li>%steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；</li>
<li>%idle CPU空闲时间比例；</li>
</ul>
</li>
<li><p>sar -q: 查看平均负载</p>
<ul>
<li>runq-sz：运行队列的长度（等待运行的进程数）</li>
<li>plist-sz：进程列表中进程（processes）和线程（threads）的数量</li>
<li>ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载</li>
<li>ldavg-15：过去15分钟的系统平均负载</li>
</ul>
</li>
<li><p>sar -r： 指定-r之后，可查看物理内存使用状况；</p>
<ul>
<li>kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li>
<li>kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li>
<li>%memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li>
<li>kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.</li>
<li>kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li>
<li>%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</li>
</ul>
</li>
<li><p>sar -W：查看页面交换发生状况</p>
<ul>
<li>pswpin&#x2F;s：每秒系统换入的交换页面（swap page）数量</li>
<li>pswpout&#x2F;s：每秒系统换出的交换页面（swap page）数量</li>
</ul>
</li>
<li><p>场景使用</p>
<ul>
<li>怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看</li>
<li>怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看</li>
<li>怀疑I&#x2F;O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看</li>
</ul>
</li>
<li><p>参数含义解释</p>
<ul>
<li>-A 汇总所有的报告</li>
<li>-a 报告文件读写使用情况</li>
<li>-B 报告附加的缓存的使用情况</li>
<li>-b 报告缓存的使用情况</li>
<li>-c 报告系统调用的使用情况</li>
<li>-d 报告磁盘的使用情况</li>
<li>-g 报告串口的使用情况</li>
<li>-h 报告关于buffer使用的统计数据</li>
<li>-m 报告IPC消息队列和信号量的使用情况</li>
<li>-n 报告命名cache的使用情况</li>
<li>-p 报告调页活动的使用情况</li>
<li>-q 报告运行队列和交换队列的平均长度</li>
<li>-R 报告进程的活动情况</li>
<li>-r 报告没有使用的内存页面和硬盘块</li>
<li>-u 报告CPU的利用率</li>
<li>-v 报告进程、i节点、文件和锁表状态</li>
<li>-w 报告系统交换活动状况</li>
<li>-y 报告TTY设备活动状况</li>
</ul>
</li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul>
<li>[简介]: Linux中的watch 命令提供了一种方式处理重复的任务。默认watch会每2秒重复执行命令。你一定也想到了,watch是一个很好的观察log文件的工具。下面是一个例子。</li>
<li>例如执行命令<code>watch -n 1 -d ps</code> 每隔一秒高亮显示进程信息</li>
</ul>
<h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><ul>
<li>[简介]:</li>
<li>样例: 如监控进程pid<code>4344</code>]信息: <code>pidstat -d -p 4344 1 3</code>，-d 展示 I&#x2F;O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据</li>
<li>参数含义: kB_rd 表示每秒读的 KB 数， kB_wr 表示每秒写的 KB 数，iodelay 表示 I&#x2F;O 的延迟（单位是时钟周期）</li>
</ul>
<h3 id="dstat"><a href="#dstat" class="headerlink" title="dstat"></a>dstat</h3><ul>
<li>[简介] dstat 是一个新的性能工具，它吸收了 vmstat、iostat、ifstat 等几种工具的优点，可以同时观察系统的 CPU、磁盘 I&#x2F;O、网络以及内存使用情况。</li>
<li>安装执行命令 <code>apt install dstat -y</code></li>
</ul>
<h2 id="文件磁盘"><a href="#文件磁盘" class="headerlink" title="文件磁盘"></a>文件磁盘</h2><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><ul>
<li>[简介] iostat 是最常用的磁盘 I&#x2F;O 性能观测工具，它提供了每个磁盘的使用率、IOPS、吞吐量等各种常见的性能指标，当然，这些指标实际上来自 &#x2F;proc&#x2F;diskstats。</li>
<li>[样例] <code>iostat -d -x 1</code></li>
<li><a href="image/004-iostat.png">参数含义</a></li>
<li>%util ，就是我们前面提到的磁盘 I&#x2F;O 使用率；</li>
<li>r&#x2F;s+ w&#x2F;s ，就是 IOPS；</li>
<li>rkB&#x2F;s+wkB&#x2F;s ，就是吞吐量；</li>
<li>r_await+w_await ，就是响应时间。</li>
</ul>
<h3 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h3><ul>
<li>[简介] 一个类似于 top 的工具，你可以按照 I&#x2F;O 大小对进程排序，然后找到 I&#x2F;O 较大的那些进程</li>
<li>[样例] <code>iotop</code></li>
</ul>
<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><ul>
<li>[简介] 用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。 找回&#x2F;恢复删除的文件</li>
<li>[样例] <code>lsof -p $pid</code> 查看对应进程关联打开的 网络、文件、设备、socket链接 等。如果要查看某个pid的TCP类型文件，执行<code>lsof -p $pid | grep TCP</code> 即可查看到监听的TCP网络及端口相关信息</li>
<li>[样例] <code>lsof -i $port</code> 查看对应端口的占用情况</li>
</ul>
<h3 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h3><ul>
<li>[简介] todo</li>
</ul>
<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><ul>
<li>[简介] todo</li>
</ul>
<h3 id="cachestat"><a href="#cachestat" class="headerlink" title="cachestat"></a>cachestat</h3><ul>
<li>[简介] 缓存命中率</li>
<li>[样例] <code>cachestat 1 3</code></li>
<li>[参数含义]<ul>
<li>TOTAL ，表示总的 I&#x2F;O 次数；</li>
<li>MISSES ，表示缓存未命中的次数；</li>
<li>HITS ，表示缓存命中的次数；</li>
<li>DIRTIES， 表示新增到缓存中的脏页数；</li>
<li>BUFFERS_MB 表示 Buffers 的大小，以 MB 为单位；</li>
<li>CACHED_MB 表示 Cache 的大小，以 MB 为单位</li>
</ul>
</li>
</ul>
<h3 id="cachetop"><a href="#cachetop" class="headerlink" title="cachetop"></a>cachetop</h3><ul>
<li>[简介] 缓存命中率：输出跟 top 类似，默认按照缓存的命中次数（HITS）排序，展示了每个进程的缓存命中情况。具体到每一个指标，这里的 HITS、MISSES 和 DIRTIES ，跟 cachestat 里的含义一样，分别代表间隔时间内的缓存命中次数、未命中次数以及新增到缓存中的脏页数。</li>
<li>[样例] <code>cachetop</code></li>
</ul>
<h3 id="slabtop"><a href="#slabtop" class="headerlink" title="slabtop"></a>slabtop</h3><ul>
<li>[简介] 实时显示内核slab内存缓存信息，使用 slabtop ，来找到占用内存最多的缓存类型。内核的模块在分配资源的时候，为了提高效率和资源的利用率，都是透过slab来分配的。通过slab的信息，再配合源码能粗粗了解系统的运行情况，比如说什么资源有没有不正常的多，或者什么资源有没有泄漏。linux系统透过&#x2F;proc&#x2F;slabinfo来向用户暴露slab的使用情况。Linux 所使用的 slab 分配器的基础是 Jeff Bonwick 为 SunOS 操作系统首次引入的一种算法。Jeff 的分配器是围绕对象缓存进行的。在内核中，会为有限的对象集（例如文件描述符和其他常见结构）分配大量内存。Jeff 发现对内核中普通对象进行初始化所需的时间超过了对其进行分配和释放所需的时间。因此他的结论是不应该将内存释放回一个全局的内存池，而是将内存保持为针对特定目而初始化的状态。Linux slab 分配器使用了这种思想和其他一些思想来构建一个在空间和时间上都具有高效性的内存分配器。保存着监视系统中所有活动的 slab 缓存的信息的文件为&#x2F;proc&#x2F;slabinfo。</li>
<li>[样例] <code>slabtop</code></li>
</ul>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><ul>
<li>[简介] 跟进程系统调用的工具,观察对应pid进程的系统调用</li>
<li>[安装] <code>apt install strace</code></li>
<li>[样例]: 运行 strace 命令，并用 -p 参数指定 PID 号 <code>strace -p 6082</code></li>
</ul>
<h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h3><ul>
<li>[简介] todo</li>
<li>[安装] todo</li>
<li>[样例]: 采样操作系统函数调用 <code>perf record -g</code>，获取调用报告 <code>perf report</code></li>
</ul>
<h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><ul>
<li>[简介]</li>
<li>[样例] <code>pstree -aps 3084</code>; a 表示输出命令行选项 ; p 表 PID; s 表示指定进程的父进程</li>
</ul>
<h3 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h3><ul>
<li><p>[简介] 内存泄露检测工具，应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56538645">内存检测王者之剑—valgrind</a></p>
</li>
<li><p>[简介]</p>
</li>
</ul>
<h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h3 id="stress"><a href="#stress" class="headerlink" title="stress"></a>stress</h3><ul>
<li>[简介] cpu、io 压测测试</li>
</ul>
<h3 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h3><ul>
<li>[简介] 网络性能测试</li>
</ul>
<h3 id="sysbench"><a href="#sysbench" class="headerlink" title="sysbench"></a>sysbench</h3><ul>
<li>[简介] sysbench是跨平台的基准测试工具</li>
</ul>
<h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><ul>
<li>[简介]Linux dd 命令用于读取、转换并输出数据。dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</li>
<li>[使用场景]适用于测试磁盘的顺序读写场景</li>
<li>[样例] 生成一个 512MB 的临时文件 <code>dd if=/dev/sda1 of=file bs=1M count=512</code>，</li>
<li>[样例] 写入指定目录文件夹路径文件 <code>dd if=/dev/zero of=/Users/lewis/fx/test.file  bs=1M  count=10000K iflag=direct</code></li>
</ul>
<h3 id="fio"><a href="#fio" class="headerlink" title="fio"></a>fio</h3><ul>
<li>[简介]: 测试磁盘的 IOPS、吞吐量以及响应时间等核心指标</li>
</ul>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="procfs"><a href="#procfs" class="headerlink" title="procfs"></a>procfs</h3><ul>
<li><p>[简介]: 在许多类 Unix 计算机系统中， procfs 是 进程 文件系统 (file system) 的缩写，包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。这个文件系统通常被挂载到 &#x2F;proc 目录。由于 &#x2F;proc 不是一个真正的文件系统，它也就不占用存储空间，只是占用有限的内存。</p>
</li>
<li><p>执行命令 <code>ls /etc/proc</code> ，即可查阅系统进程的文件信息</p>
</li>
<li><p>进程相关</p>
<ul>
<li>每个正在运行的进程对应于&#x2F;proc下的一个目录，目录名就是进程的PID，每个目录包含:</li>
<li>&#x2F;proc&#x2F;PID&#x2F;cmdline, 启动该进程的命令行.</li>
<li>&#x2F;proc&#x2F;PID&#x2F;cwd, 当前工作目录的符号链接.</li>
<li>&#x2F;proc&#x2F;PID&#x2F;environ 影响进程的环境变量的名字和值.</li>
<li>&#x2F;proc&#x2F;PID&#x2F;exe, 最初的可执行文件的符号链接, 如果它还存在的话。</li>
<li>&#x2F;proc&#x2F;PID&#x2F;fd, 一个目录，包含每个打开的文件描述符的符号链接.</li>
<li>&#x2F;proc&#x2F;PID&#x2F;fdinfo, 一个目录，包含每个打开的文件描述符的位置和标记</li>
<li>&#x2F;proc&#x2F;PID&#x2F;maps, 一个文本文件包含内存映射文件与块的信息。</li>
<li>&#x2F;proc&#x2F;PID&#x2F;mem, 一个二进制图像(image)表示进程的虚拟内存, 只能通过ptrace化进程访问.</li>
<li>&#x2F;proc&#x2F;PID&#x2F;root, 该进程所能看到的根路径的符号链接。如果没有chroot监狱，那么进程的根路径是&#x2F;.</li>
<li>&#x2F;proc&#x2F;PID&#x2F;status包含了进程的基本信息，包括运行状态、内存使用。</li>
<li>&#x2F;proc&#x2F;PID&#x2F;task, 一个目录包含了硬链接到该进程启动的任何任务</li>
</ul>
</li>
<li><p>系统相关</p>
<ul>
<li>&#x2F;proc&#x2F;softirqs 系统软中断</li>
<li>&#x2F;proc&#x2F;crypto, 可利用的加密模块列表</li>
<li>&#x2F;proc&#x2F;devices, 字符设备与块设备列表，按照设备ID排序，但给出了&#x2F;dev名字的主要部分</li>
<li>&#x2F;proc&#x2F;diskstats, 给出了每一块逻辑磁盘设备的一些信息</li>
<li>&#x2F;proc&#x2F;filesystems, 当前时刻内核支持的文件系统的列表</li>
<li>&#x2F;proc&#x2F;interrupts, &#x2F;proc&#x2F;iomem, &#x2F;proc&#x2F;ioports, &#x2F;proc&#x2F;irq, 设备的一些与中断、内存访问有  - 关的信息</li>
<li>&#x2F;proc&#x2F;kmsg, 用于跟踪读取内核消息</li>
<li>&#x2F;proc&#x2F;meminfo, 包含内核管理内存的一些汇总信息</li>
<li>&#x2F;proc&#x2F;modules, 是&#x2F;proc最重要的文件之一, 包含了当前加载的内核模块列表</li>
<li>&#x2F;proc&#x2F;mounts, 包含了当前安装设备及安装点的符号链接</li>
<li>&#x2F;proc&#x2F;net&#x2F;, 一个目录包含了当前网络栈的信息，特别是&#x2F;proc&#x2F;net&#x2F;nf_conntrack列出了存在的网络连  - 接(对跟踪路由特别有用，因为iptables转发被用于重定向网络连接)</li>
<li>&#x2F;proc&#x2F;partitions, 一个设备号、尺寸与&#x2F;dev名的列表，内核用于辨别已存在的硬盘分区</li>
<li>&#x2F;proc&#x2F;scsi, 给出任何通过SCSI或RAID控制器挂接的设备的信息</li>
<li>&#x2F;proc&#x2F;self (即&#x2F;proc&#x2F;PID&#x2F;其中进程ID是当前进程的) 为当前进程的符号链接</li>
<li>&#x2F;proc&#x2F;slabinfo, Linux内核频繁使用的对象的统计信息</li>
<li>&#x2F;proc&#x2F;swaps, 活动交换分区的信息，如尺寸、优先级等。</li>
<li>&#x2F;proc&#x2F;sys，动态可配置的内核选项. 其下的目录对应与内核区域，包含了可读与可写的虚拟文件  - （virtual file）.</li>
<li>&#x2F;proc&#x2F;sysvipc, 包括共享内存与进程间通信 (IPC)信息</li>
<li>&#x2F;proc&#x2F;tty, 包含当前终端信息; &#x2F;proc&#x2F;tty&#x2F;driver是可利用的tty类型列表，其中的每一个是该类型的  - 可用设备列表。</li>
<li>&#x2F;proc&#x2F;uptime, 内核启动后经过的秒数与idle模式的秒数</li>
<li>&#x2F;proc&#x2F;version, 包含Linux内核版本，发布号（distribution number）, 编译内核的gcc版本，其他  - 相关的版本</li>
<li>&#x2F;proc&#x2F;{pid}&#x2F;smaps，读取某个pid进程对应的虚拟内存区间到信息</li>
<li>其他文件依赖于不同的硬件，模块配置与内核改变</li>
<li>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness，Linux 提供了一个 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness 选项，用来调整使用 Swap 的积极程度。swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</li>
</ul>
</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><ul>
<li>[简介] 用于分析 DNS 的解析过程</li>
</ul>
<h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><ul>
<li>[简介] 用于分析 DNS 的解析过程</li>
</ul>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><ul>
<li>[简介] 用于测试服务器延时</li>
</ul>
<h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><ul>
<li>[简介] 用于网络抓包</li>
<li>[输出格式] <code>时间戳 协议 源地址. 源端口 &gt; 目的地址. 目的端口 网络包详细信息</code><br><img src="/image/006-tcpdump.png" alt="tcpdump-选项"><br><img src="/image/007-tcpdump.png" alt="tcpdump-表达式过滤"></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lewisbyte.github.io/2023/07/03/linux/" data-id="clwr6bi4p0006e7wy8l7b3qx6" data-title="Linux应用性能调优-LTS" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/07/db/">数据库相关</a>
          </li>
        
          <li>
            <a href="/2024/02/20/distribute_alg/">分布式技术原理与算法解析</a>
          </li>
        
          <li>
            <a href="/2024/01/31/compiler/">编译原理相关</a>
          </li>
        
          <li>
            <a href="/2023/11/21/k8s/">K8S 自学总结</a>
          </li>
        
          <li>
            <a href="/2023/09/01/cafebabe/">Java疑难杂症-LTS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 lewis<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>